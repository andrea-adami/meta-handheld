From 48be90cd9529df70724a5c57df461ecd02fab1ba Mon Sep 17 00:00:00 2001
From: Paul Parsons <lost.distance@yahoo.com>
Date: Sun, 8 Apr 2012 11:55:09 +0100
Subject: [PATCH v8] input: Add Synaptics NavPoint (PXA27x SSP/SPI) driver

This driver adds support for the Synaptics NavPoint touchpad connected
to a PXA27x SSP port in SPI slave mode. The device emulates a mouse;
a tap or tap-and-a-half drag gesture emulates the left mouse button.
For example, use the xf86-input-evdev driver for an X pointing device.

Signed-off-by: Paul Parsons <lost.distance@yahoo.com>
Cc: Philipp Zabel <philipp.zabel@gmail.com>
---

V8:
Converted from navigation pad (EV_KEY) driver to mouse (EV_ABS) driver.
Removed threaded irq handler.
Added up()/down(), called from open()/close() and resume()/suspend().
Use SIMPLE_DEV_PM_OPS().
Use dev_dbg() instead of dev_info().
Use module_platform_driver().
Added MODULE_ALIAS().
Added check for absent platform data.
Use gpio_request_one() instead of gpio_request()/gpio_direction_output()

 drivers/input/mouse/Kconfig    |   12 ++
 drivers/input/mouse/Makefile   |    1 +
 drivers/input/mouse/navpoint.c |  380 ++++++++++++++++++++++++++++++++++++++++
 include/linux/input/navpoint.h |   12 ++
 4 files changed, 405 insertions(+), 0 deletions(-)
 create mode 100644 drivers/input/mouse/navpoint.c
 create mode 100644 include/linux/input/navpoint.h

diff --git a/drivers/input/mouse/Kconfig b/drivers/input/mouse/Kconfig
index 9b8db82..cd6268c 100644
--- a/drivers/input/mouse/Kconfig
+++ b/drivers/input/mouse/Kconfig
@@ -339,4 +339,16 @@ config MOUSE_SYNAPTICS_USB
 	  To compile this driver as a module, choose M here: the
 	  module will be called synaptics_usb.
 
+config MOUSE_NAVPOINT_PXA27x
+	tristate "Synaptics NavPoint (PXA27x SSP/SPI)"
+	depends on PXA27x && PXA_SSP
+	help
+	  This driver adds support for the Synaptics NavPoint touchpad connected
+	  to a PXA27x SSP port in SPI slave mode. The device emulates a mouse;
+	  a tap or tap-and-a-half drag gesture emulates the left mouse button.
+	  For example, use the xf86-input-evdev driver for an X pointing device.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called navpoint.
+
 endif
diff --git a/drivers/input/mouse/Makefile b/drivers/input/mouse/Makefile
index 4718eff..46ba755 100644
--- a/drivers/input/mouse/Makefile
+++ b/drivers/input/mouse/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_MOUSE_GPIO)		+= gpio_mouse.o
 obj-$(CONFIG_MOUSE_INPORT)		+= inport.o
 obj-$(CONFIG_MOUSE_LOGIBM)		+= logibm.o
 obj-$(CONFIG_MOUSE_MAPLE)		+= maplemouse.o
+obj-$(CONFIG_MOUSE_NAVPOINT_PXA27x)	+= navpoint.o
 obj-$(CONFIG_MOUSE_PC110PAD)		+= pc110pad.o
 obj-$(CONFIG_MOUSE_PS2)			+= psmouse.o
 obj-$(CONFIG_MOUSE_PXA930_TRKBALL)	+= pxa930_trkball.o
diff --git a/drivers/input/mouse/navpoint.c b/drivers/input/mouse/navpoint.c
new file mode 100644
index 0000000..7d5db52
--- /dev/null
+++ b/drivers/input/mouse/navpoint.c
@@ -0,0 +1,380 @@
+/*
+ *  Copyright (C) 2012 Paul Parsons <lost.distance@yahoo.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/input/navpoint.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/pxa2xx_ssp.h>
+#include <linux/slab.h>
+
+/*
+ *	Synaptics NavPoint (PXA27x SSP/SPI) driver.
+ */
+
+/*
+ *	Synaptics Modular Embedded Protocol: Module Packet Format.
+ *	Module header byte 2:0 = Length (# bytes that follow)
+ *	Module header byte 4:3 = Control
+ *	Module header byte 7:5 = Module Address
+ */
+#define HEADER_LENGTH(byte)	((byte) & 0x07)
+#define HEADER_CONTROL(byte)	(((byte) >> 3) & 0x03)
+#define HEADER_ADDRESS(byte)	((byte) >> 5)
+
+struct driver_data {
+	struct mutex		mutex;
+	int			opened;
+	struct ssp_device	*ssp;
+	int			gpio;
+	struct input_dev	*input;
+	int			index;
+	uint8_t			data[1+HEADER_LENGTH(0xff)];
+};
+
+/*
+ *	Initialization values for SSCR0_x, SSCR1_x, SSSR_x.
+ */
+static const u32 sscr0 = 0
+	| SSCR0_TUM		/* TIM = 1; No TUR interrupts */
+	| SSCR0_RIM		/* RIM = 1; No ROR interrupts */
+	| SSCR0_SSE		/* SSE = 1; SSP enabled */
+	| SSCR0_Motorola	/* FRF = 0; Motorola SPI */
+	| SSCR0_DataSize(16)	/* DSS = 15; Data size = 16-bit */
+	;
+static const u32 sscr1 = 0
+	| SSCR1_SCFR		/* SCFR = 1; SSPSCLK only during transfers */
+	| SSCR1_SCLKDIR		/* SCLKDIR = 1; Slave mode */
+	| SSCR1_SFRMDIR		/* SFRMDIR = 1; Slave mode */
+	| SSCR1_RWOT		/* RWOT = 1; Receive without transmit mode */
+	| SSCR1_RxTresh(1)	/* RFT = 0; Receive FIFO threshold = 1 */
+	| SSCR1_SPH		/* SPH = 1; SSPSCLK inactive 0.5 + 1 cycles */
+	| SSCR1_RIE		/* RIE = 1; Receive FIFO interrupt enabled */
+	;
+static const u32 sssr = 0
+	| SSSR_BCE		/* BCE = 1; Clear BCE */
+	| SSSR_TUR		/* TUR = 1; Clear TUR */
+	| SSSR_EOC		/* EOC = 1; Clear EOC */
+	| SSSR_TINT		/* TINT = 1; Clear TINT */
+	| SSSR_PINT		/* PINT = 1; Clear PINT */
+	| SSSR_ROR		/* ROR = 1; Clear ROR */
+	;
+
+/*
+ *	MEP Query $22: Touchpad Coordinate Range Query is not supported by
+ *	the NavPoint module, so sampled values provide the default limits.
+ */
+static int xmin = 1278;
+module_param(xmin, int, 0644);
+MODULE_PARM_DESC(xmin, "Minimum X coordinate. Default = 1278");
+static int xmax = 5340;
+module_param(xmax, int, 0644);
+MODULE_PARM_DESC(xmax, "Maximum X coordinate. Default = 5340");
+static int ymin = 1572;
+module_param(ymin, int, 0644);
+MODULE_PARM_DESC(ymin, "Minimum Y coordinate. Default = 1572");
+static int ymax = 4396;
+module_param(ymax, int, 0644);
+MODULE_PARM_DESC(ymax, "Maximum Y coordinate. Default = 4396");
+static int pmin = 0;
+module_param(pmin, int, 0644);
+MODULE_PARM_DESC(pmin, "Minimum pressure. Default = 0");
+static int pmax = 255;
+module_param(pmax, int, 0644);
+MODULE_PARM_DESC(pmax, "Maximum pressure. Default = 255");
+
+static void navpoint_packet(struct device *dev)
+{
+	struct driver_data *drv_data = dev_get_drvdata(dev);
+	int finger;
+	int gesture;
+	int x, y, z;
+
+	switch (drv_data->data[0]) {
+	case 0xff:	/* Garbage (packet?) between reset and Hello packet */
+	case 0x00:	/* Module 0, NULL packet */
+		break;
+	case 0x0e:	/* Module 0, Absolute packet */
+		finger = (drv_data->data[1] & 0x01);
+		gesture = (drv_data->data[1] & 0x02);
+		x = ((drv_data->data[2] & 0x1f) << 8) | drv_data->data[3];
+		y = ((drv_data->data[4] & 0x1f) << 8) | drv_data->data[5];
+		z = drv_data->data[6];
+		input_report_key(drv_data->input, BTN_TOUCH, finger);
+		input_report_abs(drv_data->input, ABS_X, x);
+		input_report_abs(drv_data->input, ABS_Y, y);
+		input_report_abs(drv_data->input, ABS_PRESSURE, z);
+		input_report_key(drv_data->input, BTN_TOOL_FINGER, finger);
+		input_report_key(drv_data->input, BTN_LEFT, gesture);
+		input_sync(drv_data->input);
+		break;
+	case 0x19:	/* Module 0, Hello packet */
+		if ((drv_data->data[1] & 0xf0) == 0x10)
+			break;
+		/* FALLTHROUGH */
+	default:
+		dev_warn(dev, "spurious packet: data=0x%02x,0x%02x,...\n",
+			drv_data->data[0],
+			drv_data->data[1]);
+		break;
+	}
+}
+
+static irqreturn_t navpoint_int(int irq, void *dev_id)
+{
+	struct device *dev = dev_id;
+	struct driver_data *drv_data = dev_get_drvdata(dev);
+	struct ssp_device *ssp = drv_data->ssp;
+	u32 status;
+	irqreturn_t ret;
+
+	status = pxa_ssp_read_reg(ssp, SSSR);
+	ret = IRQ_NONE;
+
+	if (status & sssr) {
+		dev_warn(dev, "unexpected interrupt: status=0x%08x\n", status);
+		pxa_ssp_write_reg(ssp, SSSR, (status & sssr));
+		ret = IRQ_HANDLED;
+	}
+
+	while (status & SSSR_RNE) {
+		u32 data;
+
+		data = pxa_ssp_read_reg(ssp, SSDR);
+		drv_data->data[drv_data->index + 0] = (data >> 8);
+		drv_data->data[drv_data->index + 1] = data;
+		drv_data->index += 2;
+		if (HEADER_LENGTH(drv_data->data[0]) < drv_data->index) {
+			navpoint_packet(dev);
+			drv_data->index = 0;
+		}
+		status = pxa_ssp_read_reg(ssp, SSSR);
+		ret = IRQ_HANDLED;
+	}
+
+	return ret;
+}
+
+static void navpoint_up(struct device *dev)
+{
+	struct driver_data *drv_data = dev_get_drvdata(dev);
+	struct ssp_device *ssp = drv_data->ssp;
+	int timeout;
+
+	clk_prepare_enable(ssp->clk);
+
+	pxa_ssp_write_reg(ssp, SSCR1, sscr1);
+	pxa_ssp_write_reg(ssp, SSSR, sssr);
+	pxa_ssp_write_reg(ssp, SSTO, 0);
+	pxa_ssp_write_reg(ssp, SSCR0, sscr0);	/* SSCR0_SSE written last */
+
+	/* Wait until SSP port is ready for slave clock operations */
+	for (timeout = 100; timeout != 0; --timeout) {
+		if (!(pxa_ssp_read_reg(ssp, SSSR) & SSSR_CSS))
+			break;
+		msleep(1);
+	}
+	if (timeout == 0)
+		dev_err(dev, "timeout waiting for SSSR[CSS] to clear\n");
+
+	if (gpio_is_valid(drv_data->gpio))
+		gpio_set_value(drv_data->gpio, 1);
+}
+
+static void navpoint_down(struct device *dev)
+{
+	struct driver_data *drv_data = dev_get_drvdata(dev);
+	struct ssp_device *ssp = drv_data->ssp;
+
+	if (gpio_is_valid(drv_data->gpio))
+		gpio_set_value(drv_data->gpio, 0);
+
+	pxa_ssp_write_reg(ssp, SSCR0, 0);
+
+	clk_disable_unprepare(ssp->clk);
+}
+
+static int navpoint_open(struct input_dev *input)
+{
+	struct driver_data *drv_data = dev_get_drvdata(input->dev.parent);
+
+	mutex_lock(&drv_data->mutex);
+	navpoint_up(input->dev.parent);
+	drv_data->opened = 1;
+	mutex_unlock(&drv_data->mutex);
+	return 0;
+}
+
+static void navpoint_close(struct input_dev *input)
+{
+	struct driver_data *drv_data = dev_get_drvdata(input->dev.parent);
+
+	mutex_lock(&drv_data->mutex);
+	navpoint_down(input->dev.parent);
+	drv_data->opened = 0;
+	mutex_unlock(&drv_data->mutex);
+}
+
+static int __devinit navpoint_probe(struct platform_device *pdev)
+{
+	struct navpoint_platform_data *pdata = pdev->dev.platform_data;
+	int ret;
+	struct ssp_device *ssp;
+	struct input_dev *input;
+	struct driver_data *drv_data;
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data\n");
+		return -EINVAL;
+	}
+
+	if (gpio_is_valid(pdata->gpio)) {
+		ret = gpio_request_one(pdata->gpio, GPIOF_OUT_INIT_LOW,
+			"SYNAPTICS_ON");
+		if (ret)
+			return ret;
+	}
+
+	ssp = pxa_ssp_request(pdata->port, pdev->name);
+	if (!ssp) {
+		ret = -ENODEV;
+		goto ret1;
+	}
+
+	/* HaRET does not disable devices before jumping into Linux */
+	if (pxa_ssp_read_reg(ssp, SSCR0) & SSCR0_SSE) {
+		pxa_ssp_write_reg(ssp, SSCR0, 0);
+		dev_warn(&pdev->dev, "ssp%d already enabled\n", pdata->port);
+	}
+
+	input = input_allocate_device();
+	if (!input) {
+		ret = -ENOMEM;
+		goto ret2;
+	}
+	input->name = pdev->name;
+	__set_bit(EV_KEY, input->evbit);
+	__set_bit(EV_ABS, input->evbit);
+	__set_bit(BTN_TOUCH, input->keybit);
+	input_set_abs_params(input, ABS_X, xmin, xmax, 0, 0);
+	input_set_abs_params(input, ABS_Y, ymin, ymax, 0, 0);
+	input_set_abs_params(input, ABS_PRESSURE, pmin, pmax, 0, 0);
+	__set_bit(BTN_TOOL_FINGER, input->keybit);
+	__set_bit(BTN_LEFT, input->keybit);
+	input->open = navpoint_open;
+	input->close = navpoint_close;
+	input->dev.parent = &pdev->dev;
+
+	drv_data = kzalloc(sizeof(*drv_data), GFP_KERNEL);
+	if (!drv_data) {
+		ret = -ENOMEM;
+		goto ret3;
+	}
+	mutex_init(&drv_data->mutex);
+	drv_data->ssp = ssp;
+	drv_data->gpio = pdata->gpio;
+	drv_data->input = input;
+	platform_set_drvdata(pdev, drv_data);
+
+	ret = request_irq(ssp->irq, navpoint_int, 0, pdev->name, &pdev->dev);
+	if (ret)
+		goto ret4;
+
+	ret = input_register_device(input);
+	if (ret)
+		goto ret5;
+
+	dev_dbg(&pdev->dev, "ssp%d, irq %d\n", pdata->port, ssp->irq);
+
+	return 0;
+
+ret5:
+	free_irq(ssp->irq, &pdev->dev);
+ret4:
+	kfree(drv_data);
+ret3:
+	input_free_device(input);
+ret2:
+	pxa_ssp_free(ssp);
+ret1:
+	if (gpio_is_valid(pdata->gpio))
+		gpio_free(pdata->gpio);
+
+	return ret;
+}
+
+static int __devexit navpoint_remove(struct platform_device *pdev)
+{
+	struct driver_data *drv_data = platform_get_drvdata(pdev);
+	struct input_dev *input = drv_data->input;
+	struct ssp_device *ssp = drv_data->ssp;
+	struct navpoint_platform_data *pdata = pdev->dev.platform_data;
+
+	input_unregister_device(input);
+
+	free_irq(ssp->irq, &pdev->dev);
+
+	kfree(drv_data);
+
+	pxa_ssp_free(ssp);
+
+	if (gpio_is_valid(pdata->gpio))
+		gpio_free(pdata->gpio);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int navpoint_suspend(struct device *dev)
+{
+	struct driver_data *drv_data = dev_get_drvdata(dev);
+
+	mutex_lock(&drv_data->mutex);
+	if (drv_data->opened)
+		navpoint_down(dev);
+	mutex_unlock(&drv_data->mutex);
+	return 0;
+}
+
+static int navpoint_resume(struct device *dev)
+{
+	struct driver_data *drv_data = dev_get_drvdata(dev);
+
+	mutex_lock(&drv_data->mutex);
+	if (drv_data->opened)
+		navpoint_up(dev);
+	mutex_unlock(&drv_data->mutex);
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(navpoint_pm_ops, navpoint_suspend, navpoint_resume);
+
+static struct platform_driver navpoint_driver = {
+	.probe		= navpoint_probe,
+	.remove		= __devexit_p(navpoint_remove),
+	.driver = {
+		.name	= "navpoint",
+		.owner	= THIS_MODULE,
+		.pm	= &navpoint_pm_ops,
+	},
+};
+
+module_platform_driver(navpoint_driver);
+
+MODULE_AUTHOR("Paul Parsons <lost.distance@yahoo.com>");
+MODULE_DESCRIPTION("Synaptics NavPoint (PXA27x SSP/SPI) driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:navpoint");
diff --git a/include/linux/input/navpoint.h b/include/linux/input/navpoint.h
new file mode 100644
index 0000000..45050eb
--- /dev/null
+++ b/include/linux/input/navpoint.h
@@ -0,0 +1,12 @@
+/*
+ *  Copyright (C) 2012 Paul Parsons <lost.distance@yahoo.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+struct navpoint_platform_data {
+	int		port;		/* PXA SSP port for pxa_ssp_request() */
+	int		gpio;		/* GPIO for power on/off */
+};
-- 
1.7.3.4

